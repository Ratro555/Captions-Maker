<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Captions GIF Maker (Audio Reactive)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Bangers&family=Montserrat:wght@400;700;900&family=Oswald:wght@400;700&family=Poppins:wght@400;700;900&family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #0f0f0f;
            color: #eee;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        #canvas-wrapper {
            background-image:
              linear-gradient(45deg, #1f1f1f 25%, transparent 25%),
              linear-gradient(-45deg, #1f1f1f 25%, transparent 25%),
              linear-gradient(45deg, transparent 75%, #1f1f1f 75%),
              linear-gradient(-45deg, transparent 75%, #1f1f1f 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #111;
            box-shadow: inset 0 0 50px #000;
        }
        canvas { cursor: move; }
        input[type="range"] { accent-color: #8b5cf6; }
        input[type="checkbox"] { accent-color: #8b5cf6; cursor: pointer; }
        
        .glass-panel {
            background: rgba(20, 20, 20, 0.95);
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        textarea {
            resize: none;
            scrollbar-width: thin;
            scrollbar-color: #555 #1a1a1a;
        }
        select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23a78bfa%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 0.65em auto;
        }
        ::-webkit-scrollbar { height: 6px; width: 6px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- Header -->
    <div class="bg-black p-3 flex justify-between items-center shadow-lg z-20 border-b border-gray-800">
        <div class="flex items-center gap-2">
            <div class="bg-violet-600 w-8 h-8 rounded flex items-center justify-center font-bold text-white text-lg">C</div>
            <h1 class="font-bold text-lg tracking-wide">Captions <span class="text-violet-500">Maker</span></h1>
        </div>
        <div class="flex gap-3 items-center">
            
            <div class="flex gap-1 mr-2 border-r border-gray-700 pr-3">
                <button id="bgToggleBtn" onclick="toggleBg()" class="bg-gray-800 hover:bg-gray-700 text-gray-300 p-2 rounded text-xs transition border border-gray-700" title="–ó–µ–ª–µ–Ω—ã–π —Ñ–æ–Ω (–•—Ä–æ–º–∞–∫–µ–π)">
                    <i class="fas fa-fill-drip"></i>
                </button>
                <button onclick="exportSettings()" class="bg-gray-800 hover:bg-gray-700 text-gray-300 p-2 rounded text-xs transition border border-gray-700" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (JSON)">
                    <i class="fas fa-save"></i>
                </button>
                <label class="bg-gray-800 hover:bg-gray-700 text-gray-300 p-2 rounded text-xs transition border border-gray-700 cursor-pointer" title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (JSON)">
                    <i class="fas fa-folder-open"></i>
                    <input type="file" id="jsonInput" accept=".json" class="hidden" onchange="importSettings(this)">
                </label>
            </div>

             <label class="cursor-pointer bg-gray-800 hover:bg-gray-700 px-3 py-2 rounded text-xs transition flex items-center gap-2 border border-gray-700">
                <i class="fas fa-file-audio text-violet-400"></i> MP3
                <input type="file" id="audioInput" accept="audio/*" class="hidden">
            </label>

            <div class="flex gap-2">
                <button id="recordBtn" class="bg-violet-600 hover:bg-violet-700 px-4 py-2 rounded text-xs font-bold shadow-lg transition flex items-center gap-2 disabled:opacity-50 disabled:grayscale" disabled>
                    <i class="fas fa-video"></i> <span>GIF</span>
                </button>
                <button id="recordVideoBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-xs font-bold shadow-lg transition flex items-center gap-2 disabled:opacity-50 disabled:grayscale" disabled title="–ó–∞–ø–∏—Å–∞—Ç—å –∫–∞–∫ MP4 (WebM)">
                    <i class="fas fa-film"></i> <span>MP4</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Main Workspace -->
    <div class="flex-1 flex relative">
        <div class="w-72 bg-[#1a1a1a] border-r border-gray-800 p-4 flex flex-col gap-3 z-10">
            <div class="flex justify-between items-center">
                <label class="text-xs font-bold text-gray-400 uppercase tracking-widest">–°—É–±—Ç–∏—Ç—Ä—ã</label>
                <span class="text-[10px] text-gray-500 bg-gray-900 px-2 py-0.5 rounded border border-gray-800">–§–æ—Ä–º–∞—Ç: 1:(–¢–µ–∫—Å—Ç)</span>
            </div>
            
            <textarea id="textInput" class="flex-1 bg-black border border-gray-800 rounded-lg p-3 text-sm text-gray-200 focus:border-violet-500 outline-none leading-relaxed font-mono" placeholder="1:(–ü—Ä–∏–≤–µ—Ç –º–∏—Ä)
2:(–≠—Ç–æ –ø–ª–∞–≤–Ω—ã–µ)
3:(–°—É–±—Ç–∏—Ç—Ä—ã)"></textarea>
            
            <button id="micBtn" class="bg-gray-800 hover:bg-gray-700 py-3 rounded text-xs font-bold flex items-center justify-center gap-2 transition border border-gray-700">
                <i class="fas fa-microphone"></i> –ù–ê–î–ò–ö–¢–û–í–ê–¢–¨
            </button>
        </div>

        <div class="flex-1 relative flex justify-center items-center overflow-hidden" id="canvas-wrapper">
            <canvas id="mainCanvas"></canvas>
            
            <div id="statusOverlay" class="absolute inset-0 bg-black/90 flex flex-col justify-center items-center z-50 hidden backdrop-blur-sm">
                <div class="text-violet-500 text-5xl mb-6 animate-bounce"><i class="fas fa-magic"></i></div>
                <h2 class="text-2xl font-bold mb-2">–°–æ–∑–¥–∞–µ–º –º–∞–≥–∏—é...</h2>
                <p class="text-gray-400 text-sm mb-4">–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∫–∞–¥—Ä–æ–≤ –∞–Ω–∏–º–∞—Ü–∏–∏</p>
                <div class="w-64 h-1.5 bg-gray-800 rounded-full overflow-hidden">
                    <div id="progressBar" class="h-full bg-violet-500 w-0 transition-all duration-300"></div>
                </div>
                <p id="progressText" class="mt-3 text-xs font-mono text-gray-500">0%</p>
            </div>

            <div id="placeholder" class="absolute text-center pointer-events-none opacity-40">
                <div class="border-2 border-dashed border-gray-600 rounded-xl p-8">
                    <i class="fas fa-list-ol text-6xl mb-4 text-gray-600"></i>
                    <p class="font-bold">–§–æ—Ä–º–∞—Ç –°—Ü–µ–Ω–∞—Ä–∏—è</p>
                    <p class="text-sm mt-1">1:(–¢–µ–∫—Å—Ç –ø–µ—Ä–≤–æ–π —Ñ—Ä–∞–∑—ã)</p>
                    <p class="text-sm">2:(–¢–µ–∫—Å—Ç –≤—Ç–æ—Ä–æ–π —Ñ—Ä–∞–∑—ã)</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls Bottom -->
    <div class="glass-panel p-4 h-56 overflow-x-auto">
        <div class="flex justify-center gap-8 min-w-max px-4">
            
            <!-- Playback -->
            <div class="flex flex-col items-center justify-center w-32 gap-3 border-r border-gray-800 pr-6">
                <div class="relative group">
                    <button id="playBtn" class="w-14 h-14 rounded-full bg-white text-black flex items-center justify-center text-xl hover:scale-105 transition shadow-[0_0_20px_rgba(255,255,255,0.3)]">
                        <i class="fas fa-play ml-1"></i>
                    </button>
                </div>
                <div class="text-xs text-gray-400 font-mono flex flex-col text-center w-full">
                    <span id="timeDisplay">00:00</span>
                    <input type="range" id="seekInput" min="0" value="0" step="0.1" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
            </div>

            <!-- Presets -->
            <div class="w-40 flex flex-col gap-2">
                <span class="text-[10px] font-bold text-violet-400 uppercase tracking-wider mb-1">–°—Ç–∏–ª—å</span>
                <div class="grid grid-cols-1 gap-2">
                    <button onclick="setPreset('pop')" class="preset-btn bg-gray-800 hover:bg-gray-700 text-left px-3 py-2 rounded text-xs border border-gray-700 active-preset ring-1 ring-violet-500">
                        ‚ö° <b>Pop</b> <span class="opacity-50 text-[9px] block">–ü–ª–∞–≤–Ω–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ</span>
                    </button>
                    <button onclick="setPreset('elastic')" class="preset-btn bg-gray-800 hover:bg-gray-700 text-left px-3 py-2 rounded text-xs border border-gray-700">
                        üåÄ <b>Elastic</b> <span class="opacity-50 text-[9px] block">–ü—Ä—É–∂–∏–Ω–∏—Å—Ç—ã–π —ç—Ñ—Ñ–µ–∫—Ç</span>
                    </button>
                    <button onclick="setPreset('motionBlur')" class="preset-btn bg-gray-800 hover:bg-gray-700 text-left px-3 py-2 rounded text-xs border border-gray-700">
                        üí® <b>Blur</b> <span class="opacity-50 text-[9px] block">–†–∞–∑–º—ã—Ç–∏–µ –≤ –¥–≤–∏–∂–µ–Ω–∏–∏</span>
                    </button>
                    <button onclick="setPreset('box')" class="preset-btn bg-gray-800 hover:bg-gray-700 text-left px-3 py-2 rounded text-xs border border-gray-700">
                        üü¶ <b>Box</b> <span class="opacity-50 text-[9px] block">–ê—É–¥–∏–æ-–ø–ª–∞—à–∫–∞</span>
                    </button>
                    <button onclick="setPreset('karaoke')" class="preset-btn bg-gray-800 hover:bg-gray-700 text-left px-3 py-2 rounded text-xs border border-gray-700">
                        üé® <b>Karaoke</b> <span class="opacity-50 text-[9px] block">–°–º–µ–Ω–∞ —Ü–≤–µ—Ç–∞</span>
                    </button>
                </div>
            </div>

            <!-- Typography -->
            <div class="w-40 flex flex-col gap-3 border-l border-gray-800 pl-6">
                <span class="text-[10px] font-bold text-violet-400 uppercase tracking-wider">–®—Ä–∏—Ñ—Ç</span>
                
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–ì–∞—Ä–Ω–∏—Ç—É—Ä–∞</label>
                    <select id="fontFamily" class="w-full bg-gray-800 text-gray-200 text-xs rounded-lg p-1.5 mt-1 border border-gray-700 focus:border-violet-500 outline-none cursor-pointer hover:bg-gray-700 transition">
                        <option value="Roboto" style="font-family: 'Roboto'">Roboto (–°—Ç–∞–Ω–¥–∞—Ä—Ç)</option>
                        <option value="Montserrat" style="font-family: 'Montserrat'">Montserrat (–®–∏—Ä–æ–∫–∏–π)</option>
                        <option value="Oswald" style="font-family: 'Oswald'">Oswald (–°–∂–∞—Ç—ã–π)</option>
                        <option value="Anton" style="font-family: 'Anton'">Anton (–ñ–∏—Ä–Ω—ã–π/Shorts)</option>
                        <option value="Bangers" style="font-family: 'Bangers'">Bangers (–ö–æ–º–∏–∫—Å)</option>
                        <option value="Poppins" style="font-family: 'Poppins'">Poppins (–ú—è–≥–∫–∏–π)</option>
                    </select>
                </div>

                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–†–∞–∑–º–µ—Ä <span>Px</span></label>
                    <input type="range" id="fontSize" min="10" max="300" value="60" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–ñ–∏—Ä–Ω–æ—Å—Ç—å</label>
                    <input type="range" id="fontWeight" min="100" max="900" step="100" value="900" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–û–±–≤–æ–¥–∫–∞</label>
                    <input type="range" id="strokeWidth" min="0" max="50" value="6" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–ò–Ω—Ç–µ—Ä–≤–∞–ª</label>
                    <input type="range" id="letterSpacing" min="-5" max="50" value="0" step="1" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
            </div>

            <!-- Layout -->
            <div class="w-32 flex flex-col gap-3 border-l border-gray-800 pl-6">
                <span class="text-[10px] font-bold text-violet-400 uppercase tracking-wider">–ú–∞–∫–µ—Ç</span>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–®–∏—Ä–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏</label>
                    <input type="range" id="maxWidth" min="100" max="1500" value="600" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–ú–µ–∂—Å—Ç—Ä–æ—á–Ω—ã–π</label>
                    <input type="range" id="lineHeight" min="0.5" max="3.0" step="0.1" value="1.2" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–û—Ç—Å—Ç—É–ø —Å–ª–æ–≤</label>
                    <input type="range" id="wordSpacing" min="0" max="150" value="15" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
            </div>

            <!-- Box Settings -->
            <div class="w-32 flex flex-col gap-3 border-l border-gray-800 pl-6">
                <span class="text-[10px] font-bold text-violet-400 uppercase tracking-wider">–ü–ª–∞—à–∫–∞</span>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–û—Ç—Å—Ç—É–ø X</label>
                    <input type="range" id="boxPadX" min="0" max="200" value="20" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–û—Ç—Å—Ç—É–ø Y</label>
                    <input type="range" id="boxPadY" min="0" max="200" value="10" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between">–°–º–µ—â–µ–Ω–∏–µ Y</label>
                    <input type="range" id="boxOffsetY" min="-200" max="200" value="0" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
            </div>

            <!-- Details (Color & FPS) -->
            <div class="w-32 flex flex-col gap-3 border-l border-gray-800 pl-6">
                <span class="text-[10px] font-bold text-violet-400 uppercase tracking-wider">–î–µ—Ç–∞–ª–∏</span>
                <div class="flex justify-between items-center">
                    <label class="text-[10px] text-gray-400">–¢–µ–∫—Å—Ç</label>
                    <input type="color" id="baseColor" value="#ffffff" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                </div>
                <div class="flex justify-between items-center">
                    <label class="text-[10px] text-gray-400">–ê–∫—Ç–∏–≤–Ω—ã–π</label>
                    <input type="color" id="activeColor" value="#ffffff" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                </div>
                <div class="flex justify-between items-center">
                    <label class="text-[10px] text-gray-400">–ü–ª–∞—à–∫–∞</label>
                    <input type="color" id="highlightColor" value="#8b5cf6" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                </div>
                <div class="flex justify-between items-center">
                    <label class="text-[10px] text-gray-400">–û–±–≤–æ–¥–∫–∞</label>
                    <div class="flex flex-col items-end">
                        <input type="color" id="strokeColor" value="#000000" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                        <div class="flex items-center gap-1 mt-1">
                            <input type="checkbox" id="fixBlackStroke" class="w-3 h-3 rounded border-gray-600 bg-gray-700 text-violet-500 focus:ring-0">
                            <label for="fixBlackStroke" class="text-[9px] text-gray-500 cursor-pointer select-none">–§–∏–∫—Å —á—ë—Ä–Ω–æ–≥–æ</label>
                        </div>
                    </div>
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 flex justify-between items-center">
                        FPS <span id="fpsDisplay" class="text-violet-400 font-bold">30</span>
                    </label>
                    <input type="range" id="fpsInput" min="10" max="60" value="30" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1">
                </div>
            </div>
        </div>
    </div>

    <audio id="audioSource" crossorigin="anonymous"></audio>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const audio = document.getElementById('audioSource');
        
        const playBtn = document.getElementById('playBtn');
        const recordBtn = document.getElementById('recordBtn');
        const recordVideoBtn = document.getElementById('recordVideoBtn'); // NEW
        const audioInput = document.getElementById('audioInput');
        const textInput = document.getElementById('textInput');
        const micBtn = document.getElementById('micBtn');
        const seekInput = document.getElementById('seekInput');
        const timeDisplay = document.getElementById('timeDisplay');
        const statusOverlay = document.getElementById('statusOverlay');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const placeholder = document.getElementById('placeholder');
        const fpsInput = document.getElementById('fpsInput');
        const fpsDisplay = document.getElementById('fpsDisplay');

        // --- BACKGROUND STATE ---
        let isGreenBg = false;
        function toggleBg() {
            isGreenBg = !isGreenBg;
            const btn = document.getElementById('bgToggleBtn');
            if (isGreenBg) {
                btn.classList.replace('text-gray-300', 'text-green-500');
                btn.classList.add('border-green-500');
            } else {
                btn.classList.replace('text-green-500', 'text-gray-300');
                btn.classList.remove('border-green-500');
            }
            if(!isPlaying) draw();
        }

        // --- WEB AUDIO API SETUP ---
        let audioCtx;
        let analyser;
        let source;

        function initAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256; // –†–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
                source = audioCtx.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioCtx.destination);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function getAudioAmplitude() {
            if (!analyser) return 0;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // –°—á–∏—Ç–∞–µ–º —Å—Ä–µ–¥–Ω—é—é –≥—Ä–æ–º–∫–æ—Å—Ç—å
            let sum = 0;
            for(let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –æ—Ç 0 –¥–æ 1
            return sum / bufferLength / 255;
        }
        // ---------------------------

        function getVal(id, defaultVal) {
            const el = document.getElementById(id);
            return el ? el.value : defaultVal;
        }

        function setVal(id, val) {
            const el = document.getElementById(id);
            if (el) el.value = val;
        }

        const settings = {
            preset: 'pop',
            fontFamily: document.getElementById('fontFamily'), 
            baseColor: document.getElementById('baseColor'),
            activeColor: document.getElementById('activeColor'),
            highlightColor: document.getElementById('highlightColor'),
            strokeColor: document.getElementById('strokeColor'),
            fixBlackStroke: document.getElementById('fixBlackStroke'), 
            fontSize: document.getElementById('fontSize'),
            fontWeight: document.getElementById('fontWeight'),
            strokeWidth: document.getElementById('strokeWidth'),
            letterSpacing: document.getElementById('letterSpacing'), 
            maxWidth: document.getElementById('maxWidth'),
            lineHeight: document.getElementById('lineHeight'),
            wordSpacing: document.getElementById('wordSpacing'),
            boxPadX: document.getElementById('boxPadX'), 
            boxPadY: document.getElementById('boxPadY'),
            boxOffsetY: document.getElementById('boxOffsetY'),
            fps: fpsInput
        };
        
        Object.keys(settings).forEach(key => {
            const el = settings[key];
            if(el && typeof el === 'object' && el.tagName) {
                const eventType = (el.tagName === 'SELECT' || el.type === 'color' || el.type === 'file' || el.type === 'checkbox') ? 'change' : 'input';
                el.addEventListener(eventType, () => {
                     if(!isPlaying) draw();
                });
            }
        });
        
        let currentPreset = 'pop';

        if(fpsInput) {
            fpsInput.addEventListener('input', () => {
                if(fpsDisplay) fpsDisplay.innerText = fpsInput.value;
            });
        }

        window.exportSettings = function() {
            const data = {
                preset: currentPreset,
                fontFamily: getVal('fontFamily', 'Roboto'), 
                baseColor: getVal('baseColor', '#ffffff'),
                activeColor: getVal('activeColor', '#facc15'),
                highlightColor: getVal('highlightColor', '#8b5cf6'),
                strokeColor: getVal('strokeColor', '#000000'),
                fixBlackStroke: document.getElementById('fixBlackStroke').checked,
                fontSize: getVal('fontSize', 60),
                fontWeight: getVal('fontWeight', 700),
                strokeWidth: getVal('strokeWidth', 6),
                letterSpacing: getVal('letterSpacing', 0), 
                maxWidth: getVal('maxWidth', 600),
                lineHeight: getVal('lineHeight', 1.2),
                wordSpacing: getVal('wordSpacing', 15),
                boxPadX: getVal('boxPadX', 20),
                boxPadY: getVal('boxPadY', 10),
                boxOffsetY: getVal('boxOffsetY', 0),
                fps: getVal('fpsInput', 30)
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'captions_preset.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        window.importSettings = function(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.preset) {
                        currentPreset = data.preset;
                        document.querySelectorAll('.preset-btn').forEach(btn => {
                            btn.classList.remove('ring-1', 'ring-violet-500');
                            if(btn.innerText.toLowerCase().includes(data.preset)) {
                                btn.classList.add('ring-1', 'ring-violet-500');
                            }
                        });
                    }
                    setVal('fontFamily', data.fontFamily || 'Roboto'); 
                    setVal('baseColor', data.baseColor);
                    setVal('activeColor', data.activeColor);
                    setVal('highlightColor', data.highlightColor);
                    setVal('strokeColor', data.strokeColor);
                    if (document.getElementById('fixBlackStroke')) {
                        document.getElementById('fixBlackStroke').checked = !!data.fixBlackStroke;
                    }
                    setVal('fontSize', data.fontSize);
                    setVal('fontWeight', data.fontWeight);
                    setVal('strokeWidth', data.strokeWidth);
                    setVal('letterSpacing', data.letterSpacing || 0); 
                    setVal('maxWidth', data.maxWidth);
                    setVal('lineHeight', data.lineHeight);
                    setVal('wordSpacing', data.wordSpacing);
                    setVal('boxPadX', data.boxPadX);
                    setVal('boxPadY', data.boxPadY);
                    setVal('boxOffsetY', data.boxOffsetY);
                    setVal('fpsInput', data.fps);
                    if(fpsDisplay) fpsDisplay.innerText = data.fps;
                    draw(); 
                    alert("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!");
                } catch (err) {
                    console.error(err);
                    alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫.");
                }
                input.value = ''; 
            };
            reader.readAsText(file);
        };

        let segments = []; 
        let isPlaying = false;
        let isRecording = false;
        let isRecordingVideo = false; // NEW
        let isDraggingSeek = false;
        let animationId;
        let smoothBox = { x: 0, y: 0, w: 0, h: 0, initialized: false };
        let boxPulseScale = 1.0;
        let lastActiveWordIndex = -1;
        let lastActiveSegmentIndex = -1;
        let pos = { x: 0, y: 0 };
        let isDragging = false;

        function resize() {
            canvas.width = document.getElementById('canvas-wrapper').clientWidth;
            canvas.height = document.getElementById('canvas-wrapper').clientHeight;
            if (pos.x === 0) {
                pos.x = canvas.width / 2;
                pos.y = canvas.height / 2;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        window.setPreset = function(presetName) {
            currentPreset = presetName;
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('ring-1', 'ring-violet-500');
            });
            event.currentTarget.classList.add('ring-1', 'ring-violet-500');

            if (presetName === 'pop') {
                setVal('activeColor', '#facc15'); 
                setVal('strokeWidth', 8);
                setVal('strokeColor', '#000000');
                setVal('wordSpacing', 25); 
                setVal('letterSpacing', 0);
            } else if (presetName === 'elastic') { 
                setVal('activeColor', '#fbbf24'); 
                setVal('strokeWidth', 8);
                setVal('wordSpacing', 20);
                setVal('letterSpacing', 0);
            } else if (presetName === 'motionBlur') { 
                setVal('activeColor', '#f472b6'); 
                setVal('strokeWidth', 6);
                setVal('wordSpacing', 30);
                setVal('letterSpacing', 0);
            } else if (presetName === 'box') {
                setVal('activeColor', '#ffffff');
                setVal('highlightColor', '#8b5cf6'); 
                setVal('strokeWidth', 0);
                setVal('wordSpacing', 15);
                setVal('letterSpacing', 0);
            } else if (presetName === 'karaoke') {
                setVal('baseColor', '#555555');
                setVal('activeColor', '#facc15');
                setVal('strokeWidth', 0);
                setVal('wordSpacing', 10);
                setVal('letterSpacing', 0);
            }
            if (!isPlaying) draw();
        };

        function updateWords() {
            const rawText = textInput.value;
            const regex = /(\d+)\s*:\s*\(([^)]+)\)/g;
            const matches = [...rawText.matchAll(regex)];
            segments = [];
            if (matches.length > 0) {
                matches.forEach(m => {
                    const id = parseInt(m[1]);
                    const text = m[2].trim();
                    if (text) {
                        segments.push({
                            id: id,
                            text: text,
                            words: text.split(/\s+/).filter(w => w.length > 0)
                        });
                    }
                });
                segments.sort((a, b) => a.id - b.id);
            } else {
                const trimmed = rawText.trim();
                if (trimmed) {
                    segments.push({
                        id: 1,
                        text: trimmed,
                        words: trimmed.split(/\s+/).filter(w => w.length > 0)
                    });
                }
            }
            smoothBox.initialized = false;
            if (!isPlaying) draw();
        }
        textInput.addEventListener('input', updateWords);

        function calculateLayout(wordList) {
            if (!wordList || wordList.length === 0) return [];
            
            const fontSize = parseInt(getVal('fontSize', 60));
            const fontWeight = getVal('fontWeight', 700);
            const fontName = getVal('fontFamily', 'Roboto');
            const maxWidth = parseInt(getVal('maxWidth', 600));
            const lhVal = parseFloat(getVal('lineHeight', 1.2));
            const wordSpacing = parseInt(getVal('wordSpacing', 15));
            const letterSpacing = parseInt(getVal('letterSpacing', 0));

            ctx.font = `${fontWeight} ${fontSize}px '${fontName}', sans-serif`;
            if (ctx.letterSpacing !== undefined) {
                ctx.letterSpacing = `${letterSpacing}px`;
            }

            const lh = fontSize * lhVal;
            const spaceWidth = ctx.measureText(' ').width;

            let lines = [];
            let currentLine = [];
            let currentLineWidth = 0;

            wordList.forEach((word, index) => {
                const metrics = ctx.measureText(word);
                const wordWidth = metrics.width;
                const spacing = currentLine.length > 0 ? (spaceWidth + wordSpacing) : 0;

                if (currentLineWidth + spacing + wordWidth > maxWidth && currentLine.length > 0) {
                    lines.push({ words: currentLine, width: currentLineWidth });
                    currentLine = [];
                    currentLineWidth = 0;
                }
                const actualSpacing = currentLine.length > 0 ? (spaceWidth + wordSpacing) : 0;
                currentLine.push({ text: word, width: wordWidth, index: index });
                currentLineWidth += actualSpacing + wordWidth;
            });
            if (currentLine.length > 0) lines.push({ words: currentLine, width: currentLineWidth });

            const totalHeight = lines.length * lh;
            const startY = pos.y - (totalHeight / 2) + (lh / 2); 

            let layoutWords = [];
            lines.forEach((line, lineIdx) => {
                let startX = pos.x - (line.width / 2);
                const y = startY + (lineIdx * lh);
                line.words.forEach((w, i) => {
                    const centerX = startX + (w.width / 2);
                    layoutWords.push({
                        text: w.text,
                        x: centerX,
                        y: y,
                        width: w.width,
                        index: w.index
                    });
                    startX += w.width + spaceWidth + wordSpacing;
                });
            });
            return layoutWords;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // --- PASS: BACKGROUND ---
            if (isGreenBg) {
                ctx.fillStyle = "#00FF00";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            if (segments.length === 0) {
                if (!audio.src) return;
                ctx.fillStyle = isGreenBg ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.2)";
                ctx.font = "bold 30px 'Roboto'";
                ctx.textAlign = "center";
                ctx.fillText("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç: 1:(–¢–µ–∫—Å—Ç)", pos.x, pos.y);
                return;
            }

            let progress = 0;
            if (audio.duration > 0) progress = audio.currentTime / audio.duration;
            if (progress > 1) progress = 1;
            
            const totalSegments = segments.length;
            const segmentIndex = Math.floor(progress * totalSegments);
            const clampedSegmentIndex = Math.min(segmentIndex, totalSegments - 1);
            const currentSegment = segments[clampedSegmentIndex];
            
            const segmentDuration = 1 / totalSegments;
            const segmentStartProgress = clampedSegmentIndex * segmentDuration;
            
            let localProgress = (progress - segmentStartProgress) / segmentDuration;
            if (localProgress < 0) localProgress = 0;
            if (localProgress > 1) localProgress = 1;
            
            const floatIndex = localProgress * currentSegment.words.length;
            const activeWordIndex = Math.floor(floatIndex);

            const layout = calculateLayout(currentSegment.words);
            const preset = currentPreset;
            
            const fontSize = parseInt(getVal('fontSize', 60));
            const strokeW = parseInt(getVal('strokeWidth', 6));
            const fontWeight = getVal('fontWeight', 700);
            const fontName = getVal('fontFamily', 'Roboto');
            const letterSpacing = parseInt(getVal('letterSpacing', 0));

            if (activeWordIndex !== lastActiveWordIndex || clampedSegmentIndex !== lastActiveSegmentIndex) {
                boxPulseScale = 1.25; 
                lastActiveWordIndex = activeWordIndex;
                lastActiveSegmentIndex = clampedSegmentIndex;
            }

            // --- Independent Elements: Box, etc. ---
            if (preset === 'box') {
                const safeIndex = Math.min(Math.max(activeWordIndex, 0), layout.length - 1);
                const targetW = layout[safeIndex];
                if (targetW) {
                    const offY = parseInt(getVal('boxOffsetY', 0));
                    
                    const userMaxPadX = parseInt(getVal('boxPadX', 20));
                    const userMaxPadY = parseInt(getVal('boxPadY', 10));

                    const boxTargetW = targetW.width;
                    const boxTargetH = fontSize; 
                    const boxTargetX = targetW.x; 
                    const boxTargetY = targetW.y + offY;

                    if (!smoothBox.initialized || Math.abs(boxTargetY - smoothBox.y) > fontSize) {
                        smoothBox.x = boxTargetX;
                        smoothBox.y = boxTargetY;
                        smoothBox.w = boxTargetW;
                        smoothBox.h = boxTargetH;
                        smoothBox.initialized = true;
                    } else {
                        const speed = 0.25; 
                        smoothBox.x += (boxTargetX - smoothBox.x) * speed;
                        smoothBox.y += (boxTargetY - smoothBox.y) * speed;
                        smoothBox.w += (boxTargetW - smoothBox.w) * speed;
                        smoothBox.h += (boxTargetH - smoothBox.h) * speed;
                    }

                    const minPad = 4; 
                    let amp = 0;
                    if (isPlaying && analyser) {
                         amp = Math.min(1.0, getAudioAmplitude() * 2.5); 
                    }
                    
                    const currentPadX = minPad + (userMaxPadX - minPad) * amp;
                    const currentPadY = minPad + (userMaxPadY - minPad) * amp;

                    ctx.save();
                    ctx.translate(Math.round(smoothBox.x), Math.round(smoothBox.y));
                    
                    ctx.fillStyle = getVal('highlightColor', '#8b5cf6');
                    ctx.beginPath();
                    
                    const drawW = smoothBox.w + (currentPadX * 2);
                    const drawH = smoothBox.h + (currentPadY * 2);
                    
                    ctx.roundRect(-drawW/2, -drawH/2, drawW, drawH, 12);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // --- Main Text Properties ---
            ctx.font = `${fontWeight} ${fontSize}px '${fontName}', sans-serif`;
            if (ctx.letterSpacing !== undefined) {
                ctx.letterSpacing = `${letterSpacing}px`;
            }
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            const fixBlack = document.getElementById('fixBlackStroke').checked;
            let strokeC = getVal('strokeColor', '#000000');
            if (fixBlack && strokeC === '#000000') {
                strokeC = '#010101'; 
            }

            // --- PASS 1: STROKE (Background Layer) ---
            if (strokeW > 0) {
                layout.forEach(w => {
                    const dist = Math.abs(w.index - floatIndex);
                    let scale = 1.0;
                    let angle = 0;

                    if (preset === 'pop') {
                        if (dist < 1.5) scale = 1.0 + (0.25 * (1.0 - (dist / 1.5)));
                    } 
                    else if (preset === 'elastic' && dist < 2.0) {
                        const decay = Math.max(0, 1.0 - (dist / 2.0)); 
                        const wobble = Math.cos(dist * 6.0) * decay * decay;
                        scale = 1.0 + (0.5 * wobble);
                        const rotStrength = 0.1;
                        const dir = (w.index % 2 === 0) ? 1 : -1;
                        angle = dir * Math.sin(dist * 3.0) * decay * rotStrength;
                    }
                    else if (preset === 'motionBlur' && dist < 0.8 && dist > 0.0) {
                        scale = 1.0 + (0.1 * dist);
                    }
                    else if (preset === 'karaoke' && w.index === activeWordIndex) {
                        scale = 1.0 + (boxPulseScale - 1.0) * 0.5;
                    }

                    if (Math.abs(scale - 1.0) < 0.005) scale = 1.0;

                    ctx.save();
                    ctx.translate(Math.round(w.x), Math.round(w.y));
                    ctx.scale(scale, scale);
                    ctx.rotate(angle);

                    ctx.lineWidth = strokeW;
                    ctx.strokeStyle = strokeC;
                    ctx.lineJoin = 'round';
                    ctx.miterLimit = 2;

                    ctx.strokeText(w.text, 0, 0);
                    ctx.restore();
                });
            }

            // --- PASS 2: FILL (Foreground Layer) ---
            layout.forEach(w => {
                const isActive = (w.index === activeWordIndex);
                const isPast = (w.index < activeWordIndex);
                const dist = Math.abs(w.index - floatIndex); 

                let scale = 1.0;
                let angle = 0;
                let textColor = getVal('baseColor', '#ffffff');
                let alpha = 1.0;
                const activeColor = getVal('activeColor', '#facc15');

                if (preset === 'pop') {
                    if (dist < 1.5) {
                        scale = 1.0 + (0.25 * (1.0 - (dist / 1.5)));
                        if (dist < 0.5) textColor = activeColor;
                    }
                } 
                else if (preset === 'elastic') {
                    if (dist < 2.0) {
                        const decay = Math.max(0, 1.0 - (dist / 2.0)); 
                        const wobble = Math.cos(dist * 6.0) * decay * decay;
                        scale = 1.0 + (0.5 * wobble);
                        if (dist < 0.6) textColor = activeColor;
                        const rotStrength = 0.1;
                        const dir = (w.index % 2 === 0) ? 1 : -1;
                        angle = dir * Math.sin(dist * 3.0) * decay * rotStrength;
                    }
                }
                else if (preset === 'motionBlur') {
                      if (dist < 0.8) textColor = activeColor;
                      if (dist < 0.8 && dist > 0.0) {
                          const ghostAlpha = 0.2;
                          ctx.save();
                          ctx.translate(Math.round(w.x), Math.round(w.y));
                          ctx.scale(1.0 + (0.1 * dist), 1.0 + (0.1 * dist));
                          ctx.globalAlpha = ghostAlpha;
                          ctx.fillStyle = textColor;
                          ctx.translate(-8 * dist * 3, 0); 
                          ctx.fillText(w.text, 0, 0);
                          ctx.restore();
                          scale = 1.0 + (0.1 * dist);
                      }
                }
                else if (preset === 'box') {
                    if (isActive) textColor = activeColor;
                }
                else if (preset === 'karaoke') {
                    if (isActive || isPast) textColor = activeColor;
                    else textColor = getVal('baseColor', '#555555');
                    if (isActive) scale = 1.0 + (boxPulseScale - 1.0) * 0.5;
                }

                if (Math.abs(scale - 1.0) < 0.005) scale = 1.0;

                ctx.save();
                ctx.translate(Math.round(w.x), Math.round(w.y));
                ctx.scale(scale, scale);
                ctx.rotate(angle);
                ctx.globalAlpha = alpha;
                ctx.shadowBlur = 0;
                ctx.fillStyle = textColor;
                ctx.fillText(w.text, 0, 0);
                ctx.restore();
            });
        }

        function loop() {
            if (!isPlaying && !isRecording && !isRecordingVideo) return;
            if (boxPulseScale > 1.0) {
                boxPulseScale -= 0.01; 
                if (boxPulseScale < 1.005) boxPulseScale = 1.0;
            }
            draw();
            animationId = requestAnimationFrame(loop);
        }

        audioInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                audio.src = URL.createObjectURL(file);
                placeholder.style.display = 'none';
                recordBtn.disabled = false;
                recordVideoBtn.disabled = false; // NEW
                isPlaying = false;
                playBtn.innerHTML = '<i class="fas fa-play ml-1"></i>';
                seekInput.value = 0;
                smoothBox.initialized = false;
            }
        });

        playBtn.addEventListener('click', () => {
            if (!audio.src) return;
            initAudioContext();
            if (audio.paused) {
                audio.play();
                isPlaying = true;
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                loop();
            } else {
                audio.pause();
                isPlaying = false;
                playBtn.innerHTML = '<i class="fas fa-play ml-1"></i>';
                cancelAnimationFrame(animationId);
                draw();
            }
        });

        function formatTime(s) {
            const m = Math.floor(s / 60);
            const sc = Math.floor(s % 60);
            return `${m}:${sc.toString().padStart(2, '0')}`;
        }
        audio.addEventListener('loadedmetadata', () => {
            seekInput.max = audio.duration;
        });
        audio.addEventListener('timeupdate', () => {
            if (!isDraggingSeek) {
                seekInput.value = audio.currentTime;
                timeDisplay.innerText = formatTime(audio.currentTime);
            }
        });
        seekInput.addEventListener('input', () => {
            isDraggingSeek = true;
            timeDisplay.innerText = formatTime(seekInput.value);
            audio.currentTime = seekInput.value;
            draw(); 
        });
        seekInput.addEventListener('change', () => {
            isDraggingSeek = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            const r = canvas.getBoundingClientRect();
            const dx = (e.clientX - r.left) - pos.x;
            const dy = (e.clientY - r.top) - pos.y;
            if (Math.sqrt(dx*dx + dy*dy) < 300) isDragging = true;
        });
        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const r = canvas.getBoundingClientRect();
                pos.x = e.clientX - r.left;
                pos.y = e.clientY - r.top;
                if (!isPlaying) draw();
            }
        });
        window.addEventListener('mouseup', () => isDragging = false);

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            recognition.lang = 'ru-RU';
            recognition.continuous = true;
            recognition.interimResults = true;
            let isMicOn = false;

            micBtn.addEventListener('click', () => {
                if (!isMicOn) {
                    recognition.start();
                    micBtn.innerHTML = '<i class="fas fa-stop text-red-500 animate-pulse"></i> –°—Ç–æ–ø';
                    micBtn.classList.add('border-red-500');
                    isMicOn = true;
                } else {
                    recognition.stop();
                    micBtn.innerHTML = '<i class="fas fa-microphone"></i> –ù–ê–î–ò–ö–¢–û–í–ê–¢–¨';
                    micBtn.classList.remove('border-red-500');
                    isMicOn = false;
                }
            });
            recognition.onresult = (event) => {
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        textInput.value += event.results[i][0].transcript + ' ';
                        textInput.dispatchEvent(new Event('input'));
                    }
                }
            };
        } else {
            micBtn.style.display = 'none';
        }

        let gifWorkerUrl = null;
        async function getWorkerUrl() {
            if (gifWorkerUrl) return gifWorkerUrl;
            const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
            const blob = await response.blob();
            gifWorkerUrl = URL.createObjectURL(blob);
            return gifWorkerUrl;
        }

        let gif, captureInterval;
        
        recordBtn.addEventListener('click', async () => { 
            if (isRecording) stopRecording(); 
            else await startRecording(); 
        });

        async function startRecording() {
            if (!audio.src) return;
            initAudioContext();
            audio.currentTime = 0; 
            audio.play();
            playBtn.innerHTML = '<i class="fas fa-pause"></i>';
            isPlaying = true;
            loop();

            const workerUrl = await getWorkerUrl();
            gif = new GIF({
                workers: 2,
                quality: 10,
                workerScript: workerUrl,
                width: canvas.width,
                height: canvas.height,
                transparent: isGreenBg ? null : 0x000000,
                background: isGreenBg ? '#00FF00' : '#00000000'
            });

            isRecording = true;
            recordBtn.innerHTML = '<i class="fas fa-square text-red-500 animate-pulse"></i> –°–¢–û–ü';
            recordBtn.classList.add('bg-gray-800', 'border', 'border-red-500');
            recordVideoBtn.disabled = true;
            
            const captureFPS = parseInt(getVal('fpsInput', 30));
            const delay = 1000 / captureFPS;
            
            captureInterval = setInterval(() => {
                gif.addFrame(canvas, {copy: true, delay: delay});
            }, delay);
        }

        function stopRecording() {
            isRecording = false;
            clearInterval(captureInterval);
            recordBtn.innerHTML = '<i class="fas fa-video"></i> GIF';
            recordBtn.classList.remove('bg-gray-800', 'border', 'border-red-500');
            recordVideoBtn.disabled = false;
            audio.pause();
            isPlaying = false;
            cancelAnimationFrame(animationId);
            playBtn.innerHTML = '<i class="fas fa-play ml-1"></i>';

            statusOverlay.classList.remove('hidden');
            
            gif.on('progress', (p) => {
                const pct = Math.round(p * 100);
                progressBar.style.width = `${pct}%`;
                progressText.innerText = `${pct}%`;
            });

            gif.on('finished', (blob) => {
                statusOverlay.classList.add('hidden');
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'captions.gif';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                progressBar.style.width = '0%';
                progressText.innerText = '0%';
            });

            gif.render();
        }

        // --- NEW: MP4 VIDEO RECORDING LOGIC ---
        let mediaRecorder;
        let videoChunks = [];

        recordVideoBtn.addEventListener('click', () => {
            if (isRecordingVideo) stopVideoRecording();
            else startVideoRecording();
        });

        async function startVideoRecording() {
            if (!audio.src) return;
            initAudioContext();
            
            audio.currentTime = 0;
            audio.play();
            isPlaying = true;
            loop();

            const captureFPS = parseInt(getVal('fpsInput', 30));
            const canvasStream = canvas.captureStream(captureFPS);
            
            // –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º –ø–æ—Ç–æ–∫ –∞—É–¥–∏–æ –∏–∑ —ç–ª–µ–º–µ–Ω—Ç–∞ audio
            let audioStream;
            if (audio.captureStream) {
                audioStream = audio.captureStream();
            } else if (audio.mozCaptureStream) {
                audioStream = audio.mozCaptureStream();
            } else {
                console.warn("Audio capture not supported in this browser.");
            }

            // –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤–∏–¥–µ–æ –∏ –∞—É–¥–∏–æ —Ç—Ä–µ–∫–∏
            const tracks = [...canvasStream.getVideoTracks()];
            if (audioStream) tracks.push(...audioStream.getAudioTracks());
            
            const combinedStream = new MediaStream(tracks);

            // –ü—ã—Ç–∞–µ–º—Å—è –≤—ã–±—Ä–∞—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç
            let mimeType = 'video/webm;codecs=vp9,opus';
            if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm';
            if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/mp4';

            mediaRecorder = new MediaRecorder(combinedStream, { mimeType });
            videoChunks = [];

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) videoChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(videoChunks, { type: mediaRecorder.mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ mp4 –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞, —Ö–æ—Ç—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏ —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å webm
                a.download = 'captions.mp4';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            mediaRecorder.start();
            isRecordingVideo = true;
            recordVideoBtn.innerHTML = '<i class="fas fa-square text-red-500 animate-pulse"></i> –°–¢–û–ü';
            recordVideoBtn.classList.replace('bg-blue-600', 'bg-gray-800');
            recordVideoBtn.classList.add('border', 'border-red-500');
            recordBtn.disabled = true;
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ –∞—É–¥–∏–æ
            audio.onended = () => {
                if (isRecordingVideo) stopVideoRecording();
            };
        }

        function stopVideoRecording() {
            if (!isRecordingVideo) return;
            isRecordingVideo = false;
            mediaRecorder.stop();
            audio.pause();
            isPlaying = false;
            cancelAnimationFrame(animationId);
            playBtn.innerHTML = '<i class="fas fa-play ml-1"></i>';
            
            recordVideoBtn.innerHTML = '<i class="fas fa-film"></i> MP4';
            recordVideoBtn.classList.replace('bg-gray-800', 'bg-blue-600');
            recordVideoBtn.classList.remove('border', 'border-red-500');
            recordBtn.disabled = false;
            audio.onended = null;
        }
    </script>
</body>
</html>
